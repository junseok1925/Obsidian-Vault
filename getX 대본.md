
## **1. CoinRush 소개**

“CoinRush는 **실시간 가상화폐 시세 기반의 모의 투자 앱**입니다.  
가격은 초당 여러 번 바뀌며, 사용자의 잔고와 포트폴리오는  
여러 화면에서 즉시 반영되어야 합니다.  
또한 주문 시에는 현재가, 입력 수량, 잔고가 서로 결합되는  
복잡한 실시간 계산이 필요한 앱입니다.”

---

## **2. CoinRush 개발의 4대 난제**

“저희는 네 가지 기술적 난제를 정의했습니다.

첫째, **초당 수십 번 바뀌는 실시간 시세 처리**  
스크롤 중에도 버벅이지 않아야 합니다.

둘째, **지갑·포트폴리오의 전역 동기화**  
어느 화면에서 잔고가 바뀌어도 전체 화면에 즉시 반영되어야 합니다.

셋째, **복잡한 주문 유효성 검증**  
현재가(Stream), 입력값(State), 잔고(State)가 실시간으로 결합됩니다.

넷째, **의존성 분리와 유지보수성 확보**  
WebSocket, Repository, Controller가 뒤섞이면 관리가 불가능해집니다.

이 네 가지를 해결할 수 있는 방식이 필요했습니다.”

---

## **3. 실시간 시세 처리 – 왜 GetX인가**

“GetX는 `.obs` 기반으로 상태를 관리하기 때문에  
코인 리스트의 특정 index가 바뀌면 **그 요소만** 리빌드됩니다.

즉 아래 코드처럼:

`coins[index] = newCoin;`

이 한 줄만으로 PriceTile 하나만 갱신됩니다.

ListView 전체를 다시 그리지 않기 때문에  
**초당 수십 번 가격이 변해도 스크롤이 매우 부드럽게 유지됩니다.**

Bloc처럼 Event/State 폭증이 없고,  
Riverpod처럼 Provider 재빌드 연쇄가 생기지 않는 점이  
CoinRush의 실시간 성능 요구에 가장 잘 맞았습니다.”

---

## **4. 전역 지갑·포트폴리오 동기화**

“지갑(WalletController)과 포트폴리오(PortfolioController)를  
각각 독립 컨트롤러로 관리하면서도 Get.find로 공유합니다.

지갑 잔고가 업데이트되면:

`wallet.balance.value`

포트폴리오는 즉시 totalAsset을 재계산합니다.

이 구조 덕분에 주문·홈·포트폴리오 화면 모두에서  
전역 상태 반영이 **즉각적이고 자연스럽게 이루어집니다.**”

---

## **5. 복잡한 주문 유효성 검증 해결**

“주문 로직은 현재가(Stream), 입력 수량(State), 잔고(State)가  
실시간으로 결합되는 가장 복잡한 부분입니다.

GetX에서는 calculate() 하나로 해결됩니다.

`total = amount * currentPrice; isValid = wallet.balance >= total;`

Obx로 감싸면 UI가 자동으로 갱신되며,  
잔고가 부족하면 버튼이 즉시 비활성화됩니다.

StreamBuilder를 여러 개 중첩하지 않아도 되고,  
Bloc처럼 Event-State 구조를 반복적으로 만들 필요도 없습니다.”

---

## **6. 의존성 분리 – Binding으로 구조적 약점 보완**

“GetX는 자유도가 높다는 단점이 있습니다.  
하지만 우리는 Binding을 사용해 구조적으로 보완했습니다.

`Get.put(OrderController()); Get.put(WebSocketService()); Get.put(CoinRepository());`

이 방식을 통해 Controller, Service, Repository를  
명확하게 Layer로 분리했습니다.  
View는 객체 생성 없이 로직만 담당하게 되어  
구조가 명확하고 유지보수가 쉬운 형태가 됩니다.”

---

## **7. 결론 – 왜 CoinRush는 GetX를 선택했는가**

“정리하자면,

- 실시간 시세 처리 성능이 가장 우수하고
    
- 복잡한 상태 결합을 가장 단순하게 해결하며
    
- 전역 상태를 자연스럽게 동기화할 수 있고
    
- Binding을 통해 구조적 안정성까지 확보 가능하며
    
- 무엇보다 **MVP 개발 속도가 가장 빠릅니다.**
    

CoinRush의 특성상  
‘실시간성 + 반응성 + 빠른 개발 속도’가 가장 중요한 기준이었고,  
이 기준에 GetX가 가장 적합한 선택이었습니다.”









# 반론

## **반론 1 — “GetX는 유지보수성이 낮다. 전역 상태 남발하면 구조가 망가진다.”**

**→ 답변**

“그 지적은 잘못된 GetX 사용 사례에 해당합니다.  
저희는 모든 컨트롤러를 Domain 단위로 분리했고  
Binding을 통해 의존성을 중앙에서 관리하고 있습니다.

`Get.put(OrderController()); Get.put(WebSocketService()); Get.put(CoinRepository());`

즉 전역 오염이 아니라 **전역 DI 구조**이며,  
GetX의 단점이 아닌 사용 방식의 문제를 구조 설계로 해결했습니다.

또한 CoinRush는 ‘대규모 팀 프로젝트’가 아니라  
**실시간 성능과 빠른 개발이 중요한 MVP 제품**입니다.  
이 환경에서는 GetX의 가벼움과 생산성이 더 맞습니다.”

---

## **반론 2 — “Bloc은 Event → State 구조가 명확해서 실수할 여지가 없다.”**

**→ 답변**

“맞습니다. Bloc은 구조적으로 매우 안정적입니다.  
하지만 그 구조를 갖추기 위해 **이벤트·상태·Bloc 파일을 계속 만들어야 합니다.**

실시간 업데이트가 초당 수십 번 일어나는 CoinRush에서는  
Event 폭증과 Stream 과부하가 발생합니다.

GetX는 변경된 index만 갱신합니다.

`coins[index] = newCoin;`

Bloc처럼 Event를 무한히 생성하지 않기 때문에  
**실시간 성능에서는 GetX가 더 경량적이고 효율적입니다.**”

---

## **반론 3 — “GetX는 테스트가 힘들다.”**

**→ 답변**

“CoinRush MVP에서는 UI 테스트보다  
실시간 반응성과 기능 구현 속도가 더 중요했습니다.

또한 테스트는 Service / Repository 레이어에서 진행할 것이며  
해당 레이어는 GetX와 무관하게 독립되어 있습니다.

즉,  
**GetX의 테스트 난이도는 CoinRush의 목표를 해치지 않습니다.**”

---

## **반론 4 — “Bloc은 실시간 Stream 처리에 강하다.”**

**→ 답변**

“Stream 처리 자체는 Bloc이 강하지만  
**초당 수십 번 들어오는 가격 이벤트**를 Event/State로 변환하는 것은 오히려 과부하입니다.

GetX는 Event 변환 없이 즉시 상태만 갱신하므로 훨씬 효율적입니다.”

---

# 🟦 **2. Riverpod 팀의 예상 반론 + 답변**

---

## **반론 1 — “Riverpod은 구조적이고 안전하다. GetX는 구조가 약하다.”**

**→ 답변**

“맞습니다. Riverpod은 구조적이며 대규모 유지보수에 좋습니다.  
하지만 그 대신 내부 의존성 구조가 복잡하고,  
실시간 업데이트가 많으면 Provider 재빌드 범위를 직접 최적화해야 합니다.

StreamProvider → 여러 Provider로 전파되는 구조는  
튜닝 난이도가 높습니다.

CoinRush는 대규모 서비스가 아니라  
**‘실시간 성능 + 개발 속도’ 중심의 MVP**입니다.  
그 특성에는 GetX의 단순성과 반응성이 훨씬 잘 맞습니다.”

---

## **반론 2 — “Riverpod은 Rebuild 최적화가 좋다.”**

**→ 답변**

“Riverpod의 최적화는 수동적입니다.  
select(), ProviderScope, Provider override 등  
개발자가 직접 최적화 코드를 작성해야 합니다.

반면 GetX는 기본 구조만 써도  
리스트의 특정 요소 하나만 자동으로 리빌드됩니다.

`coins[index] = newCoin; // 해당 PriceTile만 업데이트`

CoinRush의 ‘초고주파 실시간 시세 UI’에는  
**GetX의 자동 미세 리빌드가 더 효과적입니다.**”

---

## **반론 3 — “Riverpod이 공식 문서에서도 추천되는 추세다.”**

**→ 답변**

“공식 추천과 실제 프로젝트 요구사항은 다릅니다.

CoinRush는

- 초당 수십 번의 가격 변화
    
- 다중 상태의 실시간 결합
    
- 빠른 MVP 개발  
    이 핵심입니다.
    

공식 추세보다 중요한 건  
**프로젝트 요구에 가장 적합한 기술을 선택하는 것**이며,  
이번 요구사항에서는 GetX가 가장 효율적입니다.”

---

## **반론 4 — “Provider가 명확해서 협업에 유리하다.”**

**→ 답변**

“저희는 GetX에서도 Binding을 통해 아키텍처를 명확하게 분리했습니다.

- Controller
    
- Repository
    
- Service
    

이렇게 Layer가 독립되어 있어서  
협업 시 구조를 파악하기 쉽습니다.

GetX가 ‘아키텍처가 없다’는 말은  
잘못된 파일 구조에서 나온 오해이며,  
저희는 그 부분을 이미 해결한 상태입니다.”

---

# 🟩 **3. 중립 참가자·심사위원이 할 수 있는 예상 질문 + 답변**

---

## **Q. “Riverpod이나 Bloc이 더 안정적인데 왜 성능을 기준으로 선택했나?”**

**A.**  
“CoinRush에서는  
**실시간 반응속도 = 사용자 경험 그 자체**입니다.  
따라서 성능 기준이 가장 중요했습니다.”

---

## **Q. GetX는 앞으로 팀 규모가 커지면 문제가 생기지 않나?**

**A.**  
“MVP에서 빠르게 기능을 만들고 검증하는 것이 우선이며,  
구조적 문제는 Binding과 Layer 분리로 이미 해결했습니다.”

---

## **Q. 실시간 처리 말고 다른 기능에도 GetX가 유리한가?**

**A.**  
“전역 상태 관리(지갑, 포트폴리오)에서도  
가장 단순한 구조로 즉각적인 UI 반영이 가능합니다.”

---

# 🟧 **4. 가장 효과적인 최종 한 줄 반박**

- “GetX의 단점은 구조 설계로 보완할 수 있지만,  
    Bloc과 Riverpod의 실시간 성능 단점은 근본적으로 해결이 어렵다.”
    
- “CoinRush의 요구는 대규모 협업이 아니라 실시간 반응성이다.”
    
- “기술 선택은 트렌드가 아니라 ‘문제 해결 능력’ 중심이어야 한다.”
    

---

원하면 이 내용을 **발표용 스크립트 형태로 더 자연스럽게 말하는 버전**,  
또는 **PPT에 바로 넣을 텍스트 요약 버전**으로 다시 구성해줄 수 있다.