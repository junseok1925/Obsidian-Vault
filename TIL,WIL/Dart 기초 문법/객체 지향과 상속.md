
# 상속

**부모클래스(super class)** 의 속성과 메서드를 **자식클래스(sub class)** 가 물려받아 사용할 수 있는 기능
코드 재사용성을 높이고, 공통된 기능은 부모에 두고 자식 클래스는 특화된 기능만 추가

## 기본 상속 문법
```dart
class animal {
	void main(){
		print('짖는다');
	}
}

class dog extends animal{
	void bark(){
		print('멍멍');
	}
}

void main() {
	var dog = Dog();
	dog.move(); // '짖는다' -> 부모 클래스 animal의 메서드 사용 가능
	dog.bark(); // '멍멍' -> 자식 클래스 dog의 메서드 또한 당연히 사용 가능
}
```
- 부모클래스 (super class)에서 정의된 메서드를 자식클래스(sub class)에서 사용 할 수 있음.

---

## 메서드 오버라이딩(Overriding)
자식 클래스가 **부모클래스의 메서드를 재정의**해서 자기 스타일대로 바꿀 수 있음
덮어 씌우기같은 역할

```dart

//부모 클래스
class Animal {
	void sound(){
		print('멍멍');	
	}
}
// 자식 클래스 (상속 받음)
class Cat extends Animal {
	@override 
	void sound(){ //부모 클래스 메서드 sound() 재정의
		print('야옹');
	}
}

void main() {
	var cat = cat();
	cat.sound(); // '야옹' 출력
}

```

---

## super 키워드
부모 클래스(super class)의 메서드나 생성자를 호출할 때 사용
부모의 기능을 유지하면서 기능을 확장하고 싶을 때 사용

```dart
class Animal{
	void sound(){
		print('소리를 낸다');
	}
}

class Dog extends Animal{
	@override
	void sound(){
		super.sound(); // 부모 메서드 호출
		print('멍멍');
	}
}

void main(){
	var dog = Dog();
	Dog dog = Dog();
	dog.sound();
	// '소리를 낸다'
	// '멍멍'
}
```

### 장점
- 코드 재사용성 증가
- 계층 구조 표현 가능 (동물 -> 육지동물 -> 강아지)
- 유지보수성 좋음
---

## 상속방지 - `final`

변수에서의 `fianl`은 한 번 값이 할당되면 변경 불가능 (재할당 불가);
```dart
final name = "강준석";
// name = "kangjunseok"; //재할당 불가
```

클래스에서의 `final` 은 그 클래스를 상속하거나 mixin으로 사용할 수 없음
하지만 해당 클래스 자체 객체 생성은 가능
```dart
final class Animal {
	void sound(){
		print('소리를 낸다');
	}
}

class Dog extends Animal { // 오류 발생 상속 불가
	@override
	void sound(){
		print('멍멍');
	}
}

void main(){
	Animal animal = Animal(); // 객체 생성
	//var animal = Animal();
	
	animal.sound(); // '소리를 낸다'
}
```

#### 참고 - `sealed` ,`base`, `interface`
1. `sealed` : 동일한 파일 안에서만 상속 가능 (외부차단)
2. `base` : 반드시 상속가능하게 하되, `super`를 통해 안전하게 사용 가능
3. `interface` : 다른 클래스가 반드시 구현만 할 수 있게

----

# 객체 지향 프로그래밍 (Object-Oriented-Programming)

**OOP** 라고 함
객체(Object)를 사용하여 프로그래밍을 구성하는 방식

**뭐가 좋음?**
1. 클래스를 통해 틀을 정의하고 여러 객체를 만들기 때문에 효율적
2. 클래스를 상속 받아서 기능을 확장할 수 있기에 코드 재사용성이 좋음
3. 클래스를 통해 만든 객체 들이 각각 독립적으로 동작하기 때문에 특정 객체를 수정해도 영향력이 적음

## 객체 지향 프로그래밍의 기본 예시 코드


#### 객체 지향적이지 못한 코드
```dart
class Animal1 {
  String tpye = '육식동물';
  List<String> name = ['호랑이', '사자', '치타'];

  void intruduce() {
    print('$tpye에는 $name가 있다.');
  }
}

class Animal2 {
  String tpye = '초식동물';
  List<String> name = ['사슴', '토끼', '기린'];

  void intruduce() {
    print('$tpye에는 $name가 있다.');
  }
}

void main() {
  Animal1 animal1 = Animal1();
  Animal2 animal2 = Animal2(); 
  animal.intruduce();
  animal.intruduce();
}

```

#### 객체 지향적 코드
```dart
class Animal1 {
	String type;
	List<String> name;
}

class Animal2 {
	
}
```

