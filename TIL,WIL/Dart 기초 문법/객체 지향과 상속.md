
# 상속

**부모클래스(super class)** 의 속성과 메서드를 **자식클래스(sub class)** 가 물려받아 사용할 수 있는 기능
코드 재사용성을 높이고, 공통된 기능은 부모에 두고 자식 클래스는 특화된 기능만 추가

## 기본 상속 문법
```dart
class animal {
	void move(){
		print('짖는다');
	}
}

class dog extends animal{
	void bark(){
		print('멍멍');
	}
}

void main() {
	var dog = Dog();
	dog.move(); // '짖는다' -> 부모 클래스 animal의 메서드 사용 가능
	dog.bark(); // '멍멍' -> 자식 클래스 dog의 메서드 또한 당연히 사용 가능
}
```
- 부모클래스 (super class)에서 정의된 메서드를 자식클래스(sub class)에서 사용 할 수 있음.

---

## 메서드 오버라이딩(Overriding)
자식 클래스가 **부모클래스의 메서드를 재정의**해서 자기 스타일대로 바꿀 수 있음
덮어 씌우기같은 역할

```dart

//부모 클래스
class Animal {
	void sound(){
		print('멍멍');	
	}
}
// 자식 클래스 (상속 받음)
class Cat extends Animal {
	@override 
	void sound(){ //부모 클래스 메서드 sound() 재정의
		print('야옹');
	}
}

void main() {
	var cat = cat();
	cat.sound(); // '야옹' 출력
}

```

---

## super 키워드
부모 클래스(super class)의 메서드나 생성자를 호출할 때 사용
부모의 기능을 유지하면서 기능을 확장하고 싶을 때 사용

```dart
class Animal{
	void sound(){
		print('소리를 낸다');
	}
}

class Dog extends Animal{
	@override
	void sound(){
		super.sound(); // 부모 메서드 호출
		print('멍멍');
	}
}

void main(){
	var dog = Dog();
	Dog dog = Dog();
	dog.sound();
	// '소리를 낸다'
	// '멍멍'
}
```

### 장점
- 코드 재사용성 증가
- 계층 구조 표현 가능 (동물 -> 육지동물 -> 강아지)
- 유지보수성 좋음
---

## 상속방지 - `final`

변수에서의 `fianl`은 한 번 값이 할당되면 변경 불가능 (재할당 불가);
```dart
final name = "강준석";
// name = "kangjunseok"; //재할당 불가
```

클래스에서의 `final` 은 그 클래스를 상속하거나 mixin으로 사용할 수 없음
하지만 해당 클래스 자체 객체 생성은 가능
```dart
final class Animal {
	void sound(){
		print('소리를 낸다');
	}
}

class Dog extends Animal { // 오류 발생 상속 불가
	@override
	void sound(){
		print('멍멍');
	}
}

void main(){
	Animal animal = Animal(); // 객체 생성
	//var animal = Animal();
	
	animal.sound(); // '소리를 낸다'
}
```

#### 참고 - `sealed` ,`base`, `interface`
1. `sealed` : 동일한 파일 안에서만 상속 가능 (외부차단)
2. `base` : 반드시 상속가능하게 하되, `super`를 통해 안전하게 사용 가능
3. `interface` : 다른 클래스가 반드시 구현만 할 수 있게

----

# 객체 지향 프로그래밍 (Object-Oriented-Programming)

**OOP** 라고 함
객체(Object)를 사용하여 프로그래밍을 구성하는 방식

**뭐가 좋음?**
1. 클래스를 통해 틀을 정의하고 여러 객체를 만들기 때문에 효율적
2. 클래스를 상속 받아서 기능을 확장할 수 있기에 코드 재사용성이 좋음
3. 클래스를 통해 만든 객체 들이 각각 독립적으로 동작하기 때문에 특정 객체를 수정해도 영향력이 적음

## 객체 지향 프로그래밍의 기본 예시 코드
#### 객체 지향적이지 못한 코드
```dart
class Animal1 {
  String tpye = '육식동물';
  List<String> name = ['호랑이', '사자', '치타'];

  void intruduce() {
    print('$tpye에는 $name가 있다.');
  }
}

class Animal2 {
  String tpye = '초식동물';
  List<String> name = ['사슴', '토끼', '기린'];

  void intruduce() {
    print('$tpye에는 $name가 있다.');
  }
}

void main() {
  Animal1 animal1 = Animal1();
  Animal2 animal2 = Animal2(); 
  animal.intruduce();
  animal.intruduce();
}

```

#### 객체 지향적 코드
```dart
class Animal {
  String type;
  List<String> name;

  Animal(this.type, this.name);

  void intruduce() {
    print('$type에는 $name이 있다.');
  }
}

void main() {
  Animal meat = Animal('육식동물', ['사자', '호랑이', '치타']);
  Animal grass = Animal('초식동물', ['사슴', '토끼', '기린']);

  print(meat.type); // 육식동물
  print(meat.name); // ['사자', '호랑이', '치타']

  print(grass.type); // 초식동물
  print(grass.name); // ['사슴', '토끼', '기린']

  meat.intruduce(); //육식동물에는 [사자, 호랑이, 치타]이 있다.
  grass.intruduce(); //초식동물에는 [사슴, 토끼, 기린]이 있다.
}
```


## 객체 지향 프로그래밍의 핵심 개념

1. **캡슐화**
	- 데이터(변수)와 메서드(함수)를 하나로 묶는것
	- 외부에서 함부로 접근 못 하도록 `private` 같은 **접근제한자**를 두기도 함
```dart
class BankAccount {
  double _balance = 0; // 외부에서 직접 접근 못함 (캡슐화)

  // 입금 메서드
  void deposit(double amount) {
      _balance += amount;
      print("$amount원이 입금되었습니다.");
  }
  // getter -> 잔액 확인 (읽기 전용)
  double get balance => _balance;
}

// getter 가 없으면 main()같은 외부 코드에서 사용 불가
void main() {
  BankAccount account = BankAccount();
  // 입금
  account.deposit(5000);
  // 잔액 출력
  print("현재 잔액: ${account.balance}원");
}

```


2. **상속**
	- 부모 클래스의 속성과 메서드를 물려받아 자식 클래스를 만드는 것
	- 코드 재사용성과 확장성이 좋아짐
```dart
class Animal {
	void sound(){
		print('짖는다');
	}
}

class Dog extends Animal {
	@override
	void sound(){
		print('멍멍');
	}
}

void main() {
  Dog dog = Dog();
  dog.sound(); // 멍멍
}

```

3. **다형성**
	- 같은 이름의 메서드가 상황(클래스)에 따라 다르게 동작하는 것
	- 즉, 하나의 이름, 여러 가지 기능
```dart
class Animal {
  void sound() {
    print('동물이 소리를 냅니다');
  }
}
class Dog extends Animal {
  @override
  void sound() {
    print('멍멍!');
  }
}
class Cat extends Animal {
  @override
  void sound() {
    print('야옹!');
  }
}
void main() {
  Animal a1 = Dog();
  Animal a2 = Cat();
  //같은 메서드이지만 다르게 행동
  a1.sound(); // 멍멍!
  a2.sound(); // 야옹!
}
```

4. **추상화**
	- 불필요한 세부 구현은 감추고, 중요한 기능만 드러내는 것을 말한다.
	- 즉, "무엇을 한다"는 행위만 정의, "어떻게 한다"는 구현은 감추는 것
	- 
	- 구체적인 구현은 상속받은 클래스가 담당
```dart

```