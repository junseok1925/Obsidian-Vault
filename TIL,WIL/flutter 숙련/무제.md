# JSON

jsondms key - value 쌍 구조
```dart
{
	'name' : '강준석',
	'age' : 29,
	'hobby' : ['헬스','영화']
}
```

dart에서는 `dart:convert` 라이브러리를 사용해서 Json 데이터를 사용할 수 있다.

## JSON → Dart 객체 (디코딩)

```dart
import 'dart:convert'

void main(){
	String jsonSTR = '{"name" : "jun", "age" : 29}'
	Map<String, dynamic> date = jsonDecode(jsonSTR);
	
	print(data['name']); // '강준석'
	print(data['age']); // 29
}
```
- `jsonDecode()` 는 문자열 → Map/List 로 변환한다

## Dart 객체 → JSON 문자열 ( 인코딩 )

```dart
Map<String, dynamic> user = {
	"name": "jun",
	"age" : 29,
};

String jsonSTR = jsonEncode(user);
print(jsonSTR); //{"name": "jun", "age" : 29}
```
- `jsonEncode()` 는 Map/List → JSON(문자열) 로 변환한다.

## flutter에서 자주 쓰는 패턴


- **User 모델**
```dart
class User {
	final String name;
	final int age;
	
	User({required this.name, required this.age});
	
	// JSON -> 객체
	factory User.fromJson(Map<String, dynamic> json){
		return User(
			name: json['name'],
			age: json['age'],
		);
	}
	
	// 객체 -> JSON
	Map<String, dynamic> toJson(){
		return{
			'name': name,
			'age': age,
		};
	}
	
}
```

**사용**
```dart
void main(){
	String jsonSTR = '{"name": "jun", "age": 29}';
	Map<String, dynamic> jsonMap = jsonDecode(jsonSTR);
	
	User user = User.fromJson(jsonMAp);
	print(user.name); // jun
	
	print(jsonEncode(user.toJson())); // {"name": "jun", "age": 29}
}
```


## 정리

| 목적            | 함수             | 변환 방향              |
| ------------- | -------------- | ------------------ |
| 서버에서 데이터 받을 때 | `jsonDecode()` | JSON 문자열 → Dart 객체 |
| 서버로 데이터 보낼 때  | `jsonEncode()` | Dart 객체 → JSON 문자열 |

---

# MVVM 아키텍처, RiverPod


Model + View + ViewModel 의 약자
Model, View, ViewModel 로 계층을 나누어서 개발

사용자 입력 → View → ViewModel → Model → ViewModel → View(화면 갱신)

- view : 사용자의 입력을 받음
- ViewModel : 입력에 따라 로직을 실행하고 Model을 제어
- Model : 실제 데이터나 비즈니스 로직 처리
- ViewModel은 Model에서 처리된 결과를 다시 View에 반영

## 장점

- 유지보스 용이 : UI와 로직이 분리되어 코드가 깔끔함
- 테스트 쉬움 : ViewModel만 단위 테스트 가능
- 재사용성 증가 : View, Model이 독립적이라 다른 화면에서도 재활용 가능

## 실습

프로젝트 생성 후 터미널에서 riverpod 라이브러리 설치

`flutter pub get flutter_reiverpod`

### main.dart (ProviderScope 설정)
```dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

void main() {
  // Myapp 이하 모든 위젯에서 Riverpod Provider를 사용할 수 있도록 설정한다.
  runApp(ProviderScope(child: const MyApp()));
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp();
  }
}
```

- `ProviderScope` = Riverpod의 **상태 저장소(Container) 관리자**
- 이 `ProviderScope` 관리자가 ViewModel를 제공할 수 있게 `ProviderScope`로 MyApp()을 묶는다
- `provider`는 **상태(state)** 를 관리하고 **위젯 간 데이터를 공유**하기 위한 구조다.  즉, Flutter에서 “변수를 여러 위젯이 함께 쓰고, 자동으로 UI를 갱신하고 싶을 때” 사용하는 **상태 관리 도구**다.

근데 왜 필요한가 `setState()`로 관리하면 안되나?
→ flutter는 기본적으로 부모 - 자식 단위로만 전달된다. 하지만 여러 화면에서 같은 데이터가 필요하면 `setState()`만으로는 관리가 어렵다.

그래서 `provider`를 사용하면…
1. 앱 전체에서 공유 가능한 데이터 저장소를 만들고
2. 데이터가 바뀔 때 자동으로 UI를 다시 그리게 된다. (코드 간결)

**요약:**

- `provider`는 데이터를 저장하고 관리하는 객체
- `ProviderScope`는 그 provider들을 담는 저장소
- `ref.watch()`로 값을 보고, `ref.read()`로 조작

→**provider는 Flutter에서 전역 상태를 안전하고 효율적으로 관리하기 위한 핵심 단위**다

---
# riverpod 실습


**데이터 흐름 요약**
```bash
서버(JSON 문자열)
   ↓
Repository (jsonDecode)
   ↓
Model (fromJson)
   ↓
ViewModel
   ↓
View(UI)
```

## Repository Class (user_repository.dart)

```dart
import 'dart:convert';
import 'package:flutter_riverpod_mvvm/user.dart';

class UserRepository {
// 1. 데이터요청
  Future<User> getUser() async {
    // 서버에서 데이터를 가져올 때는 항상 비동기로 가져온다
    await Future.delayed(Duration(seconds: 1));

    String dummy = 
		"""
		{
		  "name" : "jun",
		  "age" : 20
		}
		""";

    // 1. jsonDecode 함수 사용해서 JSON 문자열 → Map 구조로 변환
    Map<String, dynamic> map = jsonDecode(dummy);

    // 2. map데이터를 User 객체로 변환 후 반환
    return User.fromJson(map);
  }
}
```
- **데이터를 가져오거나 저장하는 역할**
- 보통은 API 서버, 데이터베이스, 파일 등 외부 데이터 소스와 통신한다.
- 여기서는 테스트용 dummy 데이터를 사용한다.

## Model Class ( user.dart )

```dart
// Model Class

class User {
  String name;
  int age;

  User({required this.name, required this.age});

  // 1. 네임드 생성자 (fromJson): json -> dart객체로 변환
  User.fromJson(Map<String, dynamic> map)
    : this(name: map['name'], age: map['age']);

  // 2. toJson 메서드: dart객체 -> JSON으로 변환
  Map<String, dynamic> toJson() {
    return {'name': name, 'age': age};
  }
}
```
- 실제 데이터를 담는 틀(모델)
- `Repository`가 만든 Map 데이터를 담는 틀(형태)
- Repository에서 받은 Map을 입력으로 받는다.
- `map['name']` → `name`, `map['age']` → `age`로 필드에 저장.
- 이제 `User` 객체로 변환되어 `user.name`, `user.age`로 접근 가능.

┌────────────────────────────────────────┐
│ Server or Dummy JSON                   │
│  → "{ "name": "jun", "age": 20 }"      │
└────────────────────────────────────────┘
                │
                ▼
       jsonDecode(String)  
                │
                ▼
┌────────────────────────────────────────┐
│ Map<String, dynamic>                   │
│  → { "name": "jun", "age": 20 }        │
└────────────────────────────────────────┘
                │
                ▼
       User.fromJson(Map)
                │
                ▼
┌────────────────────────────────────────┐
│ User 객체                              │
│  → user.name = "jun"                   │
│  → user.age = 20                       │
└────────────────────────────────────────┘



## ViewModel Class (home_view_model.dart)

```dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_riverpod_mvvm/user.dart';
import 'package:flutter_riverpod_mvvm/user_repository.dart';

// 1. 관리해야될 상태 클래스 만들기
class HomeState {
  User? user;
  HomeState(this.user);
}

// 2. 뷰모델 만들기 Notifier
class HomeViewModel extends Notifier<HomeState> {
  @override
  HomeState build() {
  // 초기 상태를 지정 (user = null).
    return HomeState(null);
  }

// 유저 데이터 요청
  void getUser() async {
  // 외부 데이터 소스 접근을 캡슐화(저장소 인스턴스 생성)
    UserRepository userRepository = UserRepository();
    
    //repository는 서버(dummy JSON)에서 User 객체를 반환.
    User user = await userRepository.getUser();
    
    //ViewModel은 그걸 받아 `state = HomeState(user)`로 상태 갱신.
    //Riverpod이 View에 “상태 바뀌었음” 알림 → UI 자동 재빌드.
    
    // User 데이터를 담은 새로운 상태를 ViewModel에 저장하고,  
	// 그 변화를 View에 알려서 UI를 자동 갱신시켜라
    state = HomeState(user);
  }
}

// 3. Provider 등록
//    Riverpod에게 “이 ViewModel을 상태로 관리해줘”라고 등록.
final HomeViewModelProvider = NotifierProvider<HomeViewModel, HomeState>(() {
  return HomeViewModel();
});
```
- `Notifier<HomeState>`는 Riverpod이 제공하는 **상태관리 베이스 클래스**.
- 내부의 `state` 변수로 현재 상태를 보관한다.
- 현재 화면이 표시할 데이터를 담는 상태 클래스

## View Class
```dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_riverpod_mvvm/home_view_model.dart';

class HomePage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(),
      body: Consumer(
        builder: (context, ref, child) {
        // ViewModel이 관리하는 상태를 제공
        // 상태가 바뀔 때마다 자동으로 build()가 실행된다
        // 즉, `name`, `age`가 바뀌면 화면이 자동으로 갱신된다.
          final HomeState = ref.watch(HomeViewModelProvider);
          
          return Column(
            children: [
              Text('name: ${HomeState.user?.name}'),
              Text('age: ${HomeState.user?.age}'),
              ElevatedButton(
                onPressed: () {
                  final viewModel = ref.read(HomeViewModelProvider.notifier);
                  viewModel.getUser();
                },
                child: Text('get Data'),
              ),
            ],
          );
        },
      ),
    );
  }
}

```

- 사용자의 입력을 받고, ViewModel의 상태를 구독해 UI로 표시하는 화면이다.
- `Consumer` : Riverpod에서 `ref.watch()` 를 쓰기 위해 필요한 위젯
-  내부에서 `ref` 객체를 제공받아 **provider를 감시(watch)** 할 수 있다.

## 전체 동작 흐름
```bash
[사용자] 버튼 클릭
   ↓
ref.read(HomeViewModelProvider.notifier).getUser()
   ↓
HomeViewModel → Repository → User 모델 생성
   ↓
state = HomeState(user)
   ↓
ref.watch(HomeViewModelProvider) 감지
   ↓
HomePage 다시 build()
   ↓
화면에 name, age 표시

```

## 데이터 흐름 요약
| 순서  | 동작                   | 설명                                                      |
| --- | -------------------- | ------------------------------------------------------- |
| 1   | 사용자가 버튼 클릭           | `HomePage`의 버튼이 눌림                                      |
| 2   | ViewModel 호출         | `ref.read(HomeViewModelProvider.notifier).getUser()` 실행 |
| 3   | Repository 요청        | ViewModel이 `UserRepository.getUser()` 호출                |
| 4   | JSON → Map → User 변환 | Repository가 데이터를 파싱해 `User` 객체 반환                       |
| 5   | 상태 업데이트              | ViewModel이 `state = HomeState(user)`로 상태 변경             |
| 6   | UI 자동 갱신             | `ref.watch(HomeViewModelProvider)` 감지 → View 다시 build   |
| 7   | 결과 표시                | `Text('name: ...')`에 새 데이터 표시                           |
