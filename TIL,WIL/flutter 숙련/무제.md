# JSON

jsondms key - value 쌍 구조
```dart
{
	'name' : '강준석',
	'age' : 29,
	'hobby' : ['헬스','영화']
}
```

dart에서는 `dart:convert` 라이브러리를 사용해서 Json 데이터를 사용할 수 있다.

## JSON → Dart 객체 (디코딩)

```dart
import 'dart:convert'

void main(){
	String jsonSTR = '{"name" : "jun", "age" : 29}'
	Map<String, dynamic> date = jsonDecode(jsonSTR);
	
	print(data['name']); // '강준석'
	print(data['age']); // 29
}
```
- `jsonDecode()` 는 문자열 → Map/List 로 변환한다

## Dart 객체 → JSON 문자열 ( 인코딩 )

```dart
Map<String, dynamic> user = {
	"name": "jun",
	"age" : 29,
};

String jsonSTR = jsonEncode(user);
print(jsonSTR); //{"name": "jun", "age" : 29}
```
- `jsonEncode()` 는 Map/List → JSON(문자열) 로 변환한다.

## flutter에서 자주 쓰는 패턴


- **User 모델**
```dart
class User {
	final String name;
	final int age;
	
	User({required this.name, required this.age});
	
	// JSON -> 객체
	factory User.fromJson(Map<String, dynamic> json){
		return User(
			name: json['name'],
			age: json['age'],
		);
	}
	
	// 객체 -> JSON
	Map<String, dynamic> toJson(){
		return{
			'name': name,
			'age': age,
		};
	}
	
}
```

**사용**
```dart
void main(){
	String jsonSTR = '{"name": "jun", "age": 29}';
	Map<String, dynamic> jsonMap = jsonDecode(jsonSTR);
	
	User user = User.fromJson(jsonMAp);
	print(user.name); // jun
	
	print(jsonEncode(user.toJson())); // {"name": "jun", "age": 29}
}
```


## 정리

| 목적            | 함수             | 변환 방향              |
| ------------- | -------------- | ------------------ |
| 서버에서 데이터 받을 때 | `jsonDecode()` | JSON 문자열 → Dart 객체 |
| 서버로 데이터 보낼 때  | `jsonEncode()` | Dart 객체 → JSON 문자열 |

---

# MVVM 아키텍처


Model + View + ViewModel 의 약자
Model, View, ViewModel 로 계층을 나누어서 개발

사용자 입력 → View → ViewModel → Model → ViewModel → View(화면 갱신)

- view : 사용자의 입력을 받음
- ViewModel : 입력에 따라 로직을 실행하고 Model을 제어
- Model : 실제 데이터나 비즈니스 로직 처리
- ViewModel은 Model에서 처리된 결과를 다시 View에 반영

## 장점

- 유지보스 용이 : UI와 로직이 분리되어 코드가 깔끔함
- 테스트 쉬움 : ViewModel만 단위 테스트 가능
- 재사용성 증가 : View, Model이 독립적이라 다른 화면에서도 재활용 가능

## 실습

프로젝트 생성 후 터미널에서 riverpod 라이브러리 설치

`flutter pub get flutter_reiverpod`

### main.dart (ProviderScope 설정)
```dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

void main() {
  // Myapp 이하 모든 위젯에서 Riverpod Provider를 사용할 수 있도록 설정한다.
  runApp(ProviderScope(child: const MyApp()));
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp();
  }
}
```

- `ProviderScope` = Riverpod의 **상태 저장소(Container) 관리자**
- 이 `ProviderScope` 관리자가 ViewModel를 제공할 수 있게 `ProviderScope`로 MyApp()을 묶는다
- `provider`는 **상태(state)** 를 관리하고 **위젯 간 데이터를 공유**하기 위한 구조다.  즉, Flutter에서 “변수를 여러 위젯이 함께 쓰고, 자동으로 UI를 갱신하고 싶을 때” 사용하는 **상태 관리 도구**다.

근데 왜 필요한가 `setState()`로 관리하면 안되나?
→ flutter는 기본적으로 부모 - 자식 단위로만 전달된다. 하지만 여러 화면에서 같은 데이터가 필요하면 `setState()`만으로는 관리가 어렵다.

그래서 `provider`를 사용하면…
1. 앱 전체에서 공유 가능한 데이터 저장소를 만들고
2. 데이터가 바뀔 때 자동으로 UI를 다시 그리게 된다. (코드 간결)

**요약:**

- `provider`는 데이터를 저장하고 관리하는 객체
- `ProviderScope`는 그 provider들을 담는 저장소
- `ref.watch()`로 값을 보고, `ref.read()`로 조작

→**provider는 Flutter에서 전역 상태를 안전하고 효율적으로 관리하기 위한 핵심 단위**다

---

