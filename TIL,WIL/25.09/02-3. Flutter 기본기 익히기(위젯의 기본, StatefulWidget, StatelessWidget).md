
==Flutter에서 위젯은 UI를 구성하는 모든 요소를 의미한다.
화면에 보여지는 버튼, 텍스트, 이미지, 레이아웃 박스, 화면 전체도 모두 위젯으로 보면 된다.
플러터의 위젯을 만드는 방법은 3가지가 존재한다.==

1. 플러터 기본 내장 위젯
	- https://docs.flutter.dev/ui/widgets
2. pub.dev에서 개발자분들이 공유하고 있는 위젯
	- https://pub.dev/
3. 본인이 직접 만드는 위젯

위젯은 클래스의 형태를 띠고 있다.
생성자, 멤버 변수, 메서드가 존재하며, **위젯은 클래스라고 볼 수 있다.**



# StatelessWidget

- 상태가 없는 위젯
- 한 번 그려지면 내부 값이 변하지 않는다 (immutable)
- UI가 단순히 데이터를 표시하기만 할 때 사용된다.
- 값이 바뀌면 새로운 위젯을 생성해서 UI를 다시 그려야 한다.
- 즉, 읽기 전용 UI용 위젯이라고 생각하면 됨

### StatelessWidget의 구조

```dart
class MyText extends StatelessWidget {
  final String text; // 외부에서 전달받는 값

  MyText(this.text);

  @override
  Widget build(BuildContext context) {
    return Text(text); // 화면에 표시할 UI
  }
}

```
- build() 함수 안에서 화면에 나타낼 UI를 정의한다.
- 외부에서 전달된 text값이 바뀌면 StatelessWidget 자체는 그 변화를 감지할 수 없음 -> 새로 생성해야 UI가 바뀐다.

### StatelessWidget의 특징

1. 상태 없음
	- 내부에서 값이 바뀌거나 버튼 클릭 시 상태를 유지하지 않음
	- 외부에서 값이 바뀌면 새 위젯 생성 필요
2. 경량
	- 상태를 관리하지 않기 때문에 StatefulWidget보다 가벼움
3. UI만 그릴 때 적합
	- 텍스트, 이미지, 아이콘, 단순 레이아웃 등..
	- 예시
  ```dart
	class ScoreDisplay extends StatelessWidget {
	final int score;
	
	ScoreDisplay({required this.score});
	
	  @override
	  Widget build(BuildContext context) {
	    return Text(
	      'Score: $score',
	      style: TextStyle(fontSize: 20),
	    );
	  }
	}
```
-> 단순 점수를 보여주는 UI, 점수가 바뀌면 새로운 ScoreDisplay 위젯을 만들어서 UI를 갱신해야 한다.

### 언제 사용해야하는가...

- 값이 변하지 않는 고정 UI
- 단순 텍스트 :  ==로그인 화면의 “환영합니다” 문구, 정보 라벨 등==
- 아이콘 : ==버튼 아이콘, 로고, 배너 이미지 등==
- 레이아웃 구성용 위젯 : ==Row, Column, Container, Padding 등을 감싸서 화면 구조를 만들 때==
- 재사용이 가능한 작은 UI 컴포넌트 : ==버튼, 카드, 리스트 아이템 등 상태 변화 필요 없는 반복 UI==
==참고: StatefulWidget과 달리 **setState()를 사용할 수 없습니다.**  
값이 바뀌면 반드시 **새로운 StatelessWidget 객체를 만들어서 build() 재호출** 필요함==


### 완전 요약...!!

- 상태 변화가 필요 없는 UI용
- 앱에서 많이 쓰이는 기능
	- 고정 텍스트, 라벨
	- 이미지, 아이콘 표시
	- 단순 레이아웃 구성
	- 재사용 가능한 작은 UI 컴포넌트
	-> 반대로 점수표시, 버튼 클릭 같은 변화가 필요한 UI에서는 statefulWidget을 사용해야한다.


---

# StatefulWidget
- 상태를 가진 위젯
- 내부 값이 바뀌면 setState()를 호출하여 UI를 다시 갱신할 수 있음
- 사용자 입력, 점수, 카드 뒤집기, 애니메이션 등 변화가 필요한 UI에 적합

### StatefulWidget 구조
```dart
class Counter extends StatefulWidget {
  @override
  _CounterState createState() => _CounterState();
}

class _CounterState extends State<Counter> {
  int count = 0; // 상태 변수

  void increment() {
    setState(() {
      count++; // 상태 값 변경
    });
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Text('Count: $count'),
        ElevatedButton(
          onPressed: increment, // 버튼 클릭 시 상태 변경
          child: Text('Increase'),
        ),
      ],
    );
  }
}

```
- `StatefulWidget` 클래스는 위젯 자체를 정의
- `_CounterState` 클래스가 상태(state)와 UI를 관리
-  상태가 바뀌면 `setState()`로  UI를 재필드


### statefulwidget 특징

1. 상태 관리 가능
	- 버튼 클릭, 카드 뒤집기, 점수 증가 등 동적인 변화 처리
2. `setState()` 호출 시 UI 갱신
	- 상태가 바뀔 때 Flutter 프레임워크에 다시 그리라고 알림
3. 복잡한 UI와 사용자 상호작용에 적합
	- 입력폼, 게임, 애니메이션, 탭 변경 등


### 언제 사용해야하는가...

1. 사용자 입력에 따라 UI가 바뀌는 경우
   - 버튼 클릭 -> 점수 증가, 토글, 체크박스 선택
   - 텍스트 입력 -> 입력값에 따라 UI 표시 변경
   ==카운터 앱, 폼 입력, 로그인 화면에서 비밀번호 보이기/숨기기==

2. 게임이나 인터랙티브 UI
   - 탭 / 페이지 이동 시 상태 저장
   - 애니메이션 진행 상태 관리
   ==매모리 매칭 게임, 슬라이드 퍼즐, 점수판 UI==

3. 동적 데이터에 따라 UI가 변하는 경우 
   - 서버에서 데이터를 받아와 화면에 표시
   ==채팅 앱, 뉴스 피드, 쇼핑 앱 상품 리스트==

4. 시간, 애니메이션, 타이머 관리
   - 타이머로 진행률 표시
   - 애니매이션 프레임에 따라 UI 갱신
   ==진행 바, 로딩 애니메이션, 게임 캐릭터 애니메이션==

### 완전 요약...!!

- **정의**: 상태(state)를 가지는 위젯. 내부 값이 바뀌면 `setState()`로 UI를 갱신할 수 있음.
    
- **언제 쓰는가**:
    1. 사용자 입력 → 버튼, 체크박스, 토글 등
    2. 게임/인터랙티브 UI → 카드 뒤집기, 점수, 애니메이션
    3. 동적 데이터 → 서버, 리스트 추가/삭제, 새로고침
    4. 시간/애니메이션 → 타이머, 진행률, 캐릭터 애니메이션
        
- **특징**:
    - 내부 상태값(state)을 가진다
    - `setState()` 호출로 UI를 갱신
    - StatelessWidget보다 무거움
    - build()가 반복 호출될 수 있음

- **사용 예시**:
    - 카운터 앱
    - 메모리 매칭 게임
    - 채팅 앱 메시지 리스트
    - 타이머 진행 바
        
- **핵심 포인트**:
    - UI가 변할 가능성이 있으면 StatefulWidget
    - UI가 고정이면 StatelessWidget



> 상태가 변할 가능성이 있는 UI = StatefulWidget
> 상태가 변하지 않는 UI = StatelessWidget


